<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mug Studio 2.6 - Real-Time 3D</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { background-color: #f0f0f0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; user-select: none; }
        
        /* UI Components */
        .win95-box { background: #c0c0c0; border: 2px solid; border-color: #dfdfdf #404040 #404040 #dfdfdf; padding: 4px; }
        .sidebar { background-color: #c0c0c0; border-right: 2px solid #808080; box-shadow: inset -1px -1px 0px #404040, inset 1px 1px 0px #dfdfdf; }
        
        .tool-btn { background-color: #c0c0c0; border: 2px solid; border-color: #dfdfdf #404040 #404040 #dfdfdf; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.1s; }
        .tool-btn:active, .tool-btn.active { border-color: #404040 #dfdfdf #dfdfdf #404040; background-color: #e0e0e0; transform: translateY(1px); }

        .canvas-container { background-color: #808080; padding: 20px; overflow: hidden; display: flex; justify-content: center; align-items: center; position: relative; }
        canvas#drawingCanvas { background-color: white; box-shadow: 4px 4px 0px rgba(0,0,0,0.2); cursor: crosshair; }
        
        #renderer-container { width: 100%; height: 300px; background: linear-gradient(to bottom, #e0e0e0, #ffffff); border-top: 2px solid #808080; position: relative; }

        .floating-panel { position: absolute; top: 60px; left: 100px; width: 250px; background: #c0c0c0; border: 2px solid #dfdfdf; border-right-color: #404040; border-bottom-color: #404040; box-shadow: 4px 4px 10px rgba(0,0,0,0.3); z-index: 50; display: none; }
        .panel-header { background: #000080; color: white; padding: 2px 4px; font-weight: bold; font-size: 12px; display: flex; justify-content: space-between; align-items: center; cursor: grab; }
        
        #imageContextBar { display: none; position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: #ffffe0; border: 1px solid #000; padding: 5px 10px; gap: 10px; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); font-size: 12px; z-index: 40; align-items: center; }

        #loadingOverlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 100; justify-content: center; align-items: center; color: white; flex-direction: column; text-align: center; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .border-option { width: 100%; text-align: left; padding: 4px; margin-bottom: 2px; font-size: 12px; cursor: pointer; border: 1px solid transparent; }
        .border-option:hover { background-color: #000080; color: white; }
    </style>
</head>
<body class="h-screen flex flex-col">

    <div id="loadingOverlay">
        <div class="spinner"></div>
        <span id="loadingText" class="font-bold text-lg">Processando...</span>
        <span class="text-sm text-gray-300 mt-2">N√£o feche a janela.</span>
    </div>

    <header class="bg-[#000080] text-white p-2 flex justify-between items-center select-none">
        <div class="font-bold tracking-wide pl-2 flex items-center gap-2">
            <i class="fas fa-coffee"></i> Mug Studio v2.6 (Live 3D)
        </div>
        <button class="win95-box text-black px-2 font-bold hover:bg-red-200" onclick="window.location.reload()">X</button>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <aside class="sidebar w-20 flex flex-col items-center py-4 gap-3 select-none z-10">
            <div class="flex flex-col items-center w-full px-2">
                <label class="text-xs mb-1 font-bold">Cor</label>
                <input type="color" id="colorPicker" value="#000000" class="w-10 h-8 cursor-pointer border-2 border-gray-600">
            </div>
            <div class="flex flex-col items-center w-full px-2">
                <label class="text-xs mb-1 font-bold">Pincel</label>
                <input type="range" id="brushSize" min="1" max="20" value="5" class="w-14">
            </div>
            <hr class="w-10 border-gray-500 my-2">
            
            <button id="btnSelect" class="tool-btn w-10 h-10 active" title="Selecionar (V)"><i class="fas fa-mouse-pointer"></i></button>
            <button id="btnPencil" class="tool-btn w-10 h-10" title="L√°pis (P)"><i class="fas fa-pencil-alt"></i></button>
            <button id="btnEraser" class="tool-btn w-10 h-10" title="Borracha (E)"><i class="fas fa-eraser"></i></button>
            
            <hr class="w-10 border-gray-500 my-2">

            <button id="btnUndo" class="tool-btn w-10 h-10 text-purple-800" title="Desfazer (Ctrl+Z)"><i class="fas fa-undo"></i></button>
            
            <div class="relative group">
                <button class="tool-btn w-10 h-10" title="Importar Imagem" onclick="document.getElementById('fileInput').click()">
                    <i class="fas fa-folder-open text-yellow-700"></i>
                </button>
                <input type="file" id="fileInput" accept="image/*" class="hidden">
            </div>
            
            <button id="btnBorders" class="tool-btn w-10 h-10 text-indigo-800" title="Adicionar Borda"><i class="fas fa-border-style"></i></button>
            <button id="btnFilters" class="tool-btn w-10 h-10 text-blue-800" title="Filtros"><i class="fas fa-sliders-h"></i></button>
            
            <div class="flex-grow"></div>
            <button id="btnClear" class="tool-btn w-10 h-10 text-red-600 mb-2" title="Limpar Tudo"><i class="fas fa-trash-alt"></i></button>
        </aside>

        <main class="flex-1 flex flex-col bg-[#808080] relative">
            
            <!-- Painel de Filtros -->
            <div id="filterPanel" class="floating-panel p-2">
                <div class="panel-header mb-2" id="filterPanelHeader">
                    <span>Filtros</span> <button id="closeFilters" class="hover:text-red-300">x</button>
                </div>
                <div class="space-y-2">
                    <div class="text-xs text-center text-gray-700 mb-2">Aplica √† camada selecionada ou fundo</div>
                    <div class="slider-group"><label>Blur</label><input type="range" id="filterBlur" class="filter-input" min="0" max="10" value="0" step="0.5"></div>
                    <div class="slider-group">
                        <label>Modo</label>
                        <select id="filterMode" class="filter-input w-full text-xs p-1 border">
                            <option value="normal">Normal</option>
                            <option value="grayscale">P&B</option>
                            <option value="sepia">S√©pia</option>
                            <option value="invert">Inverter</option>
                        </select>
                    </div>
                    <hr class="border-gray-500">
                    <div class="slider-group"><label class="text-red-600">Vermelho</label><input type="range" id="channelR" class="filter-input" min="0" max="200" value="100"></div>
                    <div class="slider-group"><label class="text-green-600">Verde</label><input type="range" id="channelG" class="filter-input" min="0" max="200" value="100"></div>
                    <div class="slider-group"><label class="text-blue-600">Azul</label><input type="range" id="channelB" class="filter-input" min="0" max="200" value="100"></div>
                </div>
                <div class="flex gap-2 mt-3">
                    <button id="btnCancelFilter" class="w-1/2 win95-box text-xs font-bold text-red-700">Cancelar</button>
                    <button id="btnConfirmFilter" class="w-1/2 win95-box text-xs font-bold text-green-700">Aplicar</button>
                </div>
            </div>

            <!-- Painel de Bordas -->
            <div id="borderPanel" class="floating-panel p-2" style="left: 150px; top: 100px;">
                <div class="panel-header mb-2" id="borderPanelHeader">
                    <span>Adicionar Borda</span> <button id="closeBorders" class="hover:text-red-300">x</button>
                </div>
                <div class="bg-white border border-gray-400 p-1 h-40 overflow-y-auto">
                    <div class="border-option" onclick="applyBorder('simple')">üî≥ Simples (Preto)</div>
                    <div class="border-option" onclick="applyBorder('double')">üî≤ Dupla (P&B)</div>
                    <div class="border-option" onclick="applyBorder('colorful')">üåà Colorida (Gradiente)</div>
                    <div class="border-option" onclick="applyBorder('geometric')">üî∫ Geom√©trica</div>
                    <div class="border-option" onclick="applyBorder('baroque')">‚öúÔ∏è Barroca</div>
                    <div class="border-option font-bold text-blue-800" onclick="applyBorder('random')">üé≤ Aleat√≥ria</div>
                    <div class="border-option text-red-600 border-t mt-1 pt-1" onclick="applyBorder('none')">‚ùå Remover Borda</div>
                </div>
            </div>

            <!-- √Årea Canvas -->
            <div class="flex-1 canvas-container relative">
                <div id="imageContextBar" class="flex">
                    <span class="font-bold mr-2 text-blue-800"><i class="fas fa-image"></i> Imagem Selecionada</span>
                    <span class="text-xs text-gray-500 border-r border-gray-400 pr-2">Arraste para mover ‚Ä¢ Scroll para Zoom</span>
                    <button id="btnUnselectImg" class="hover:bg-blue-100 px-2 rounded text-blue-700 font-bold" title="Soltar sele√ß√£o"><i class="fas fa-check"></i> Soltar</button>
                    <button id="btnDeleteImg" class="hover:bg-red-100 px-2 rounded text-red-600 font-bold" title="Remover imagem"><i class="fas fa-trash"></i></button>
                </div>

                <div class="flex flex-col items-center">
                    <span class="text-white text-xs mb-1 font-mono tracking-widest">√ÅREA DE SUBLIMA√á√ÉO</span>
                    <canvas id="drawingCanvas" width="800" height="360"></canvas>
                </div>
            </div>

            <div class="bg-[#c0c0c0] p-3 border-t-2 border-gray-400 flex flex-wrap justify-between items-center gap-4 z-20">
                <div class="flex items-center gap-2 flex-grow">
                     <label class="text-xs font-bold whitespace-nowrap">Contato:</label>
                     <div class="win95-box bg-white px-2 flex gap-2 w-full max-w-lg">
                        <input type="email" id="userEmail" placeholder="E-mail (Drive)" class="outline-none text-sm w-1/2 bg-transparent">
                        <div class="w-[1px] bg-gray-400"></div>
                        <input type="tel" id="userPhone" placeholder="+55 (41) 9..." class="outline-none text-sm w-1/2 bg-transparent">
                     </div>
                </div>
                <div class="flex gap-2">
                    <!-- Bot√£o Reset atualizado e Bot√£o 3D Removido -->
                    <button id="btnReset" class="win95-box px-4 py-1 font-bold hover:bg-red-100 text-sm"><i class="fas fa-bomb mr-1"></i> Reset Total</button>
                    <button id="btnSend" class="win95-box px-4 py-1 font-bold hover:bg-green-100 text-sm whitespace-nowrap"><i class="fas fa-save mr-1"></i> Salvar Pedido</button>
                </div>
            </div>

            <div id="renderer-container">
                <div class="absolute top-2 left-2 bg-black/50 text-white text-xs px-2 py-1 rounded pointer-events-none z-10">Preview 3D (Live)</div>
            </div>
        </main>
    </div>

    <script>
        const GOOGLE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbysQfI9ECyMASiUvqoyHVY8XNKB1eUQj04gK1y3tLjzVaRRXl4xt2dVclmV-hhKbDoL/exec";
        
        // --- DOM Elements ---
        const EL = {
            canvas: document.getElementById('drawingCanvas'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            loadingText: document.getElementById('loadingText'),
            colorPicker: document.getElementById('colorPicker'),
            brushSize: document.getElementById('brushSize'),
            imgContextBar: document.getElementById('imageContextBar'),
            filterPanel: document.getElementById('filterPanel'),
            borderPanel: document.getElementById('borderPanel'),
            fileInput: document.getElementById('fileInput'),
            rendererContainer: document.getElementById('renderer-container')
        };
        const ctx = EL.canvas.getContext('2d');

        // --- ARQUITETURA OFFSCREEN CANVAS (Real-Time 3D) ---
        // O exportCanvas armazena a arte "limpa", sem caixas de sele√ß√£o, para o 3D e PDF
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = EL.canvas.width;
        exportCanvas.height = EL.canvas.height;
        const exportCtx = exportCanvas.getContext('2d');

        // --- STATE & LAYERS ---
        const state = {
            tool: 'select',
            drawingLayer: document.createElement('canvas'),
            borderLayer: document.createElement('canvas'),
            imageObject: null, 
            isDrawing: false,
            lastX: 0, lastY: 0,
            drag: { active: false, startX: 0, startY: 0 },
            history: [],
            historyStep: -1
        };

        state.drawingLayer.width = EL.canvas.width;
        state.drawingLayer.height = EL.canvas.height;
        const drawCtx = state.drawingLayer.getContext('2d');

        state.borderLayer.width = EL.canvas.width;
        state.borderLayer.height = EL.canvas.height;
        const borderCtx = state.borderLayer.getContext('2d');

        saveToHistory();
        // A renderiza√ß√£o inicial ser√° chamada ap√≥s carregar o 3D para garantir a textura correta

        // --- CORE RENDER LOOP (M√°gica do Tempo Real) ---
        function renderMain() {
            // 1. Limpa o Canvas de Exporta√ß√£o (invis√≠vel)
            exportCtx.fillStyle = "white";
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

            // 2. Desenha Imagem no Export
            if (state.imageObject) {
                const obj = state.imageObject;
                exportCtx.drawImage(obj.img, obj.x, obj.y, obj.width, obj.height);
            }

            // 3. Desenha Rabiscos e Bordas no Export
            exportCtx.drawImage(state.drawingLayer, 0, 0);
            exportCtx.drawImage(state.borderLayer, 0, 0);

            // 4. ATUALIZA A CANECA 3D IMEDIATAMENTE (com a arte limpa)
            if (window.printMesh && window.printMesh.material.map) {
                window.printMesh.material.map.needsUpdate = true;
            }

            // 5. Copia a arte limpa para o Canvas vis√≠vel (da tela)
            ctx.clearRect(0, 0, EL.canvas.width, EL.canvas.height);
            ctx.drawImage(exportCanvas, 0, 0);

            // 6. Desenha a UI (caixa azul) POR CIMA no Canvas da tela
            // Como desenhamos no ctx da tela, isso n√£o vai para o 3D!
            if (state.imageObject) {
                const obj = state.imageObject;
                if (obj.isSelected) {
                    ctx.save();
                    ctx.strokeStyle = "#0066ff"; ctx.lineWidth = 2; ctx.setLineDash([6, 4]);
                    ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                    ctx.fillStyle = "#fff";
                    [[obj.x-4, obj.y-4], [obj.x+obj.width-4, obj.y+obj.height-4]].forEach(([x,y]) => {
                        ctx.fillRect(x, y, 8, 8); ctx.strokeRect(x, y, 8, 8);
                    });
                    ctx.restore();
                    EL.imgContextBar.style.display = 'flex';
                } else {
                    EL.imgContextBar.style.display = 'none';
                }
            } else {
                EL.imgContextBar.style.display = 'none';
            }
        }

        // --- HISTORY SYSTEM ---
        function saveToHistory() {
            state.historyStep++;
            if (state.historyStep < state.history.length) state.history.length = state.historyStep;
            
            const snapshot = {
                imageObject: state.imageObject ? {...state.imageObject} : null,
                drawingData: state.drawingLayer.toDataURL(),
                borderData: state.borderLayer.toDataURL() 
            };
            state.history.push(JSON.stringify(snapshot));
            if (state.history.length > 15) { state.history.shift(); state.historyStep--; }
        }

        function undo() {
            if (state.historyStep > 0) {
                state.historyStep--;
                const snapshot = JSON.parse(state.history[state.historyStep]);
                
                if (snapshot.imageObject) {
                    const img = new Image();
                    img.onload = () => { snapshot.imageObject.img = img; state.imageObject = snapshot.imageObject; renderMain(); };
                    img.src = snapshot.imageObject.img.src;
                } else { state.imageObject = null; }

                const drawImg = new Image();
                drawImg.onload = () => {
                    drawCtx.clearRect(0,0,EL.canvas.width, EL.canvas.height);
                    drawCtx.drawImage(drawImg, 0, 0);
                    renderMain();
                };
                drawImg.src = snapshot.drawingData;

                const borderImg = new Image();
                borderImg.onload = () => {
                    borderCtx.clearRect(0,0,EL.canvas.width, EL.canvas.height);
                    borderCtx.drawImage(borderImg, 0, 0);
                    renderMain();
                }
                borderImg.src = snapshot.borderData;
            }
        }
        document.getElementById('btnUndo').addEventListener('click', undo);
        document.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); } });

        // --- BORDERS LOGIC ---
        document.getElementById('btnBorders').onclick = () => {
            EL.borderPanel.style.display = EL.borderPanel.style.display === 'block' ? 'none' : 'block';
        };
        document.getElementById('closeBorders').onclick = () => EL.borderPanel.style.display = 'none';

        let isDragBP = false, bpX, bpY;
        document.getElementById('borderPanelHeader').onmousedown = (e) => {
            isDragBP = true; bpX = e.clientX - EL.borderPanel.offsetLeft; bpY = e.clientY - EL.borderPanel.offsetTop;
        };
        window.addEventListener('mousemove', (e) => {
            if(isDragBP) { EL.borderPanel.style.left = (e.clientX - bpX)+'px'; EL.borderPanel.style.top = (e.clientY - bpY)+'px'; }
        });
        window.addEventListener('mouseup', () => isDragBP = false);

        window.applyBorder = (type) => {
            borderCtx.clearRect(0, 0, EL.canvas.width, EL.canvas.height);
            const w = EL.canvas.width; const h = EL.canvas.height; const m = 15;

            if (type === 'random') {
                const types = ['simple', 'double', 'colorful', 'geometric', 'baroque'];
                type = types[Math.floor(Math.random() * types.length)];
            }

            borderCtx.save();
            
            if (type === 'simple') {
                borderCtx.strokeStyle = 'black'; borderCtx.lineWidth = 8;
                borderCtx.strokeRect(m, m, w - m*2, h - m*2);
            }
            else if (type === 'double') {
                borderCtx.strokeStyle = 'black'; borderCtx.lineWidth = 10;
                borderCtx.strokeRect(m, m, w - m*2, h - m*2);
                borderCtx.strokeStyle = 'white'; borderCtx.lineWidth = 2;
                borderCtx.strokeRect(m + 4, m + 4, w - (m*2) - 8, h - (m*2) - 8);
                borderCtx.strokeStyle = 'black'; borderCtx.lineWidth = 2;
                borderCtx.strokeRect(m + 12, m + 12, w - (m*2) - 24, h - (m*2) - 24);
            }
            else if (type === 'colorful') {
                const gradient = borderCtx.createLinearGradient(0, 0, w, h);
                gradient.addColorStop(0, "red"); gradient.addColorStop(0.2, "orange"); gradient.addColorStop(0.4, "yellow");
                gradient.addColorStop(0.6, "green"); gradient.addColorStop(0.8, "blue"); gradient.addColorStop(1, "violet");
                borderCtx.strokeStyle = gradient; borderCtx.lineWidth = 15;
                borderCtx.strokeRect(m, m, w - m*2, h - m*2);
            }
            else if (type === 'geometric') {
                borderCtx.strokeStyle = 'black'; borderCtx.lineWidth = 4;
                borderCtx.strokeRect(m, m, w - m*2, h - m*2);
                const s = 40; 
                borderCtx.fillStyle = 'black';
                borderCtx.beginPath(); borderCtx.moveTo(m, m); borderCtx.lineTo(m+s, m); borderCtx.lineTo(m, m+s); borderCtx.fill();
                borderCtx.beginPath(); borderCtx.moveTo(w-m, m); borderCtx.lineTo(w-m-s, m); borderCtx.lineTo(w-m, m+s); borderCtx.fill();
                borderCtx.beginPath(); borderCtx.moveTo(w-m, h-m); borderCtx.lineTo(w-m-s, h-m); borderCtx.lineTo(w-m, h-m-s); borderCtx.fill();
                borderCtx.beginPath(); borderCtx.moveTo(m, h-m); borderCtx.lineTo(m+s, h-m); borderCtx.lineTo(m, h-m-s); borderCtx.fill();
            }
            else if (type === 'baroque') {
                borderCtx.strokeStyle = '#333'; borderCtx.lineWidth = 3;
                roundedRect(borderCtx, m, m, w-m*2, h-m*2, 20); borderCtx.stroke();
                roundedRect(borderCtx, m+5, m+5, w-m*2-10, h-m*2-10, 15); borderCtx.stroke();
                borderCtx.fillStyle = '#333';
                [[m+5, m+5], [w-m-5, m+5], [w-m-5, h-m-5], [m+5, h-m-5]].forEach(([x,y]) => {
                    borderCtx.beginPath(); borderCtx.arc(x, y, 8, 0, Math.PI*2); borderCtx.fill();
                });
            }

            borderCtx.restore();
            renderMain();
            saveToHistory();
        };

        function roundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius); ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius); ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath();
        }

        // --- INTERACTION ---
        function getMousePos(evt) {
            const rect = EL.canvas.getBoundingClientRect();
            const cx = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const cy = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return { x: cx - rect.left, y: cy - rect.top };
        }

        function handleStart(e) {
            if(e.type === 'touchstart') e.preventDefault();
            const pos = getMousePos(e);

            if (state.tool === 'select') {
                if (state.imageObject) {
                    const obj = state.imageObject;
                    if (pos.x >= obj.x && pos.x <= obj.x + obj.width && pos.y >= obj.y && pos.y <= obj.y + obj.height) {
                        obj.isSelected = true; state.drag.active = true;
                        state.drag.startX = pos.x - obj.x; state.drag.startY = pos.y - obj.y;
                        EL.canvas.style.cursor = 'grabbing';
                        renderMain();
                        return;
                    } else {
                        if (obj.isSelected) { obj.isSelected = false; renderMain(); }
                    }
                }
                return;
            }

            state.isDrawing = true;
            state.lastX = pos.x; state.lastY = pos.y;
            drawStroke(pos.x, pos.y, true);
        }

        function handleMove(e) {
            if(e.type === 'touchmove') e.preventDefault();
            const pos = getMousePos(e);

            if (state.tool === 'select' && state.drag.active && state.imageObject) {
                state.imageObject.x = pos.x - state.drag.startX;
                state.imageObject.y = pos.y - state.drag.startY;
                renderMain();
                return;
            }

            if (state.isDrawing && state.tool !== 'select') {
                drawStroke(pos.x, pos.y, false);
                state.lastX = pos.x; state.lastY = pos.y;
            }
        }

        function handleEnd() {
            if (state.isDrawing || state.drag.active) saveToHistory();
            state.isDrawing = false;
            state.drag.active = false;
            EL.canvas.style.cursor = state.tool === 'select' ? 'default' : 'crosshair';
        }

        function drawStroke(x, y, isDot) {
            drawCtx.beginPath();
            if (isDot) {
                drawCtx.fillStyle = state.tool === 'eraser' ? 'rgba(0,0,0,1)' : EL.colorPicker.value;
                drawCtx.globalCompositeOperation = state.tool === 'eraser' ? 'destination-out' : 'source-over';
                drawCtx.arc(x, y, EL.brushSize.value / 2, 0, Math.PI * 2);
                drawCtx.fill();
            } else {
                drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round'; drawCtx.lineWidth = EL.brushSize.value;
                drawCtx.globalCompositeOperation = state.tool === 'eraser' ? 'destination-out' : 'source-over';
                drawCtx.strokeStyle = state.tool === 'eraser' ? 'rgba(0,0,0,1)' : EL.colorPicker.value;
                drawCtx.moveTo(state.lastX, state.lastY); drawCtx.lineTo(x, y); drawCtx.stroke();
            }
            drawCtx.globalCompositeOperation = 'source-over';
            renderMain();
        }

        ['mousedown', 'touchstart'].forEach(ev => EL.canvas.addEventListener(ev, handleStart));
        ['mousemove', 'touchmove'].forEach(ev => EL.canvas.addEventListener(ev, handleMove));
        ['mouseup', 'mouseout', 'touchend'].forEach(ev => EL.canvas.addEventListener(ev, handleEnd));

        EL.canvas.addEventListener('wheel', (e) => {
            if (state.imageObject && state.imageObject.isSelected) {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 0.9 : 1.1;
                const obj = state.imageObject;
                const newW = obj.width * scale; const newH = obj.height * scale;
                obj.x += (obj.width - newW) / 2; obj.y += (obj.height - newH) / 2;
                obj.width = newW; obj.height = newH;
                renderMain();
            }
        }, { passive: false });

        // --- TOOLS ---
        const setTool = (t, id) => {
            state.tool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            if (t !== 'select' && state.imageObject) {
                state.imageObject.isSelected = false;
                renderMain();
            }
            EL.canvas.style.cursor = t === 'select' ? 'default' : 'crosshair';
        };

        document.getElementById('btnSelect').onclick = () => setTool('select', 'btnSelect');
        document.getElementById('btnPencil').onclick = () => setTool('pencil', 'btnPencil');
        document.getElementById('btnEraser').onclick = () => setTool('eraser', 'btnEraser');

        // FUN√á√ÉO DE LIMPEZA INTELIGENTE
        const clearProject = () => {
             if(confirm('Deseja limpar todo o trabalho (Canvas e Aplica√ß√£o 3D)?')) {
                state.imageObject = null;
                drawCtx.clearRect(0, 0, EL.canvas.width, EL.canvas.height);
                borderCtx.clearRect(0, 0, EL.canvas.width, EL.canvas.height);
                renderMain();
                saveToHistory();
            }
        };

        document.getElementById('btnClear').onclick = clearProject;
        document.getElementById('btnReset').onclick = clearProject;

        // --- IMAGE ---
        EL.fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => { 
                    const img = new Image();
                    img.onload = () => {
                        const aspect = img.width / img.height;
                        const h = EL.canvas.height * 0.8;
                        state.imageObject = { 
                            img: img, x: (EL.canvas.width - h*aspect)/2, y: (EL.canvas.height - h)/2, 
                            width: h*aspect, height: h, isSelected: true 
                        };
                        setTool('select', 'btnSelect');
                        renderMain();
                        saveToHistory();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            }
        });

        document.getElementById('btnUnselectImg').onclick = () => { if (state.imageObject) { state.imageObject.isSelected = false; renderMain(); } };
        document.getElementById('btnDeleteImg').onclick = () => { if (state.imageObject && confirm("Remover imagem?")) { state.imageObject = null; renderMain(); saveToHistory(); } };

        // --- FILTERS ---
        let preFilterSnapshot = null;
        document.getElementById('btnFilters').addEventListener('click', () => {
            EL.filterPanel.style.display = 'block';
            preFilterSnapshot = exportCanvas.toDataURL(); // Tira snapshot do canvas limpo
        });

        const updateFilter = () => {
            if(!preFilterSnapshot) return;
            const img = new Image();
            img.onload = () => {
                exportCtx.clearRect(0,0,exportCanvas.width, exportCanvas.height);
                exportCtx.save();
                
                const blur = document.getElementById('filterBlur').value;
                const mode = document.getElementById('filterMode').value;
                let filterStr = `blur(${blur}px)`;
                if(mode !== 'normal') filterStr += ` ${mode === 'grayscale' ? 'grayscale' : mode}(100%)`;
                exportCtx.filter = filterStr;
                exportCtx.drawImage(img, 0, 0);
                exportCtx.restore();

                const r = document.getElementById('channelR').value / 100;
                const g = document.getElementById('channelG').value / 100;
                const b = document.getElementById('channelB').value / 100;
                
                if(r !== 1 || g !== 1 || b !== 1) {
                    const idata = exportCtx.getImageData(0,0,exportCanvas.width, exportCanvas.height);
                    for(let i=0; i<idata.data.length; i+=4) {
                        idata.data[i] *= r; idata.data[i+1] *= g; idata.data[i+2] *= b;
                    }
                    exportCtx.putImageData(idata, 0, 0);
                }

                // Atualiza 3D em tempo real enquanto arrasta os filtros
                if (window.printMesh && window.printMesh.material.map) {
                    window.printMesh.material.map.needsUpdate = true;
                }

                // Atualiza a tela
                ctx.clearRect(0,0,EL.canvas.width, EL.canvas.height);
                ctx.drawImage(exportCanvas, 0, 0);
            };
            img.src = preFilterSnapshot;
        };

        document.querySelectorAll('.filter-input').forEach(el => el.addEventListener('input', updateFilter));
        
        document.getElementById('btnConfirmFilter').addEventListener('click', () => {
            const finalImg = new Image();
            finalImg.onload = () => {
                drawCtx.clearRect(0,0,EL.canvas.width, EL.canvas.height);
                borderCtx.clearRect(0,0,EL.canvas.width, EL.canvas.height); // Filtro funde as bordas tbm
                drawCtx.drawImage(finalImg, 0, 0);
                state.imageObject = null;
                renderMain();
                saveToHistory();
            }
            finalImg.src = exportCanvas.toDataURL();
            EL.filterPanel.style.display = 'none';
            preFilterSnapshot = null;
        });
        
        document.getElementById('btnCancelFilter').addEventListener('click', () => {
            EL.filterPanel.style.display = 'none';
            preFilterSnapshot = null;
            renderMain();
        });

        // --- 3D SETUP ---
        function init3D() {
            const container = EL.rendererContainer;
            scene = new THREE.Scene(); scene.background = new THREE.Color(0xe0e0e0);
            camera = new THREE.PerspectiveCamera(35, container.clientWidth/container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 4); camera.lookAt(0,0,0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(2, 5, 5); scene.add(light); scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            const group = new THREE.Group();
            const matWhite = new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.3});
            group.add(new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 1.8, 64), matWhite));
            const handle = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.12, 16, 100, Math.PI), matWhite);
            handle.rotation.z = -Math.PI/2; handle.position.set(0.8, 0, 0); group.add(handle);

            const printGeo = new THREE.CylinderGeometry(0.805, 0.805, 1.6, 64, 1, true, Math.PI - (2*Math.PI*0.85/2), 2*Math.PI*0.85);
            
            // Textura aponta para o canvas de exporta√ß√£o (limpo)
            const tex = new THREE.CanvasTexture(exportCanvas);
            const printMat = new THREE.MeshStandardMaterial({map: tex, transparent: true, side: THREE.DoubleSide});
            window.printMesh = new THREE.Mesh(printGeo, printMat);
            window.printMesh.rotation.y = Math.PI / 2;
            group.add(window.printMesh);
            scene.add(group);

            let dragging = false, lastX = 0;
            function animate() {
                requestAnimationFrame(animate);
                if(!dragging) group.rotation.y += 0.002;
                renderer.render(scene, camera);
            }
            animate();

            container.onmousedown = (e) => { dragging = true; lastX = e.offsetX; };
            window.onmouseup = () => dragging = false;
            container.onmousemove = (e) => {
                if(dragging) { group.rotation.y += (e.offsetX - lastX) * 0.01; lastX = e.offsetX; }
            };
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
            
            renderMain(); // Garante o render inicial na caneca
        }
        init3D();

        // --- EXPORT ---
        function convertPdfToBase64(pdf) {
            const pdfArray = pdf.output('arraybuffer');
            let binaryString = "";
            const bytes = new Uint8Array(pdfArray);
            for (let i = 0; i < bytes.byteLength; i++) binaryString += String.fromCharCode(bytes[i]);
            return btoa(binaryString);
        }

        document.getElementById('btnSend').onclick = async () => {
            const email = document.getElementById('userEmail').value.trim();
            const phone = document.getElementById('userPhone').value.trim();
            
            if(!email && !phone) return alert("Por favor, preencha o E-mail OU o Telefone.");
            if(phone && phone.replace(/\D/g, '').length < 12) return alert("Telefone incompleto. Padr√£o: C√≥digo Pa√≠s + DDD + N√∫mero.");
            
            if(!confirm("Salvar pedido no servidor?")) return;

            EL.loadingOverlay.style.display = 'flex';
            EL.loadingText.innerText = "Gerando PDF...";

            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({ orientation: 'landscape', unit: 'mm', format: [210, 99] });
                
                // Exporta a partir do canvas de Exporta√ß√£o (sem caixa azul)
                const imgData = exportCanvas.toDataURL("image/jpeg", 0.95);
                pdf.addImage(imgData, 'JPEG', 0, 0, 210, 99);
                
                const pdfBase64 = convertPdfToBase64(pdf);
                
                const now = new Date();
                const pad = n => n.toString().padStart(2, '0');
                const orderId = `${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}${pad(now.getHours())}${pad(now.getMinutes())}`;
                const contactId = email ? email : phone.replace(/\D/g, '');
                const filename = `${orderId}_${contactId}.pdf`;

                EL.loadingText.innerText = "Enviando...";
                
                await fetch(GOOGLE_SCRIPT_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' }, 
                    body: JSON.stringify({
                        filename: filename, mimeType: "application/pdf", data: pdfBase64,
                        email: email, phone: phone, orderId: orderId
                    })
                });

                EL.loadingOverlay.style.display = 'none';
                let msg = `Pedido #${orderId} SALVO COM SUCESSO!\n`;
                if(email) msg += "Verifique seu Google Drive ou E-mail.\n";
                msg += "\nConfirme seu pedido via WhatsApp:\n+55 (41) 99674-3862";
                alert(msg);

            } catch (err) {
                EL.loadingOverlay.style.display = 'none';
                console.error(err);
                if(confirm("Erro de conex√£o.\nDeseja baixar o PDF manualmente?")) {
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF({ orientation: 'landscape', unit: 'mm', format: [210, 99] });
                    pdf.addImage(exportCanvas.toDataURL(), 'JPEG', 0, 0, 210, 99);
                    pdf.save(`${Date.now()}_manual.pdf`);
                }
            }
        };
    </script>
</body>
</html>
